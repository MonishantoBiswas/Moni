input=binaryString
length = 8
input_l = [input[i:i+length] for i in range(0,len(input),length)]
print(input_l)
input_c = [chr(int(c,base=2)) for c in input_l]
print ("joint",''.join(input_c))
def string_decode(input, length=8):
    input_l = [input[i:i+length] for i in range(0,len(input),length)]
    return ''.join([chr(int(c,base=2)) for c in input_l])

print(string_decode(input))

01101000011001010110110001101100011011110110100001100101011011000110110001101111011010000110010101101100011011000110111101101000011001010110110001101100011011110110100001100101011011000110110001101111


01101000011001010110110001101100011011110110100001100101011011000110110001101111

import cv2
import imutils
import numpy as np
import binascii
from collections import Counter
from PIL import Image
from string import *



cap2=cv2.imread("imagesBasics/helloworld.png")
cap1=imutils.rotate_bound(cap2,angle=180)


while True:
    frame = cv2.resize(cap1, (640, 480))
    roi = frame[50:350, 300:360]
    break
gimg=cv2.cvtColor(roi,cv2.COLOR_BGR2GRAY)    # Gray image converter
new_gimg=np.zeros(gimg.shape,gimg.dtype)
contrast=5.0
bright=4
for y in range(gimg.shape[0]):               # Enhance contrast and brightness
    for x in range(gimg.shape[1]):
        new_gimg[y,x]=np.clip(contrast*gimg[y,x]+bright,0,255)


ret,threshimg=cv2.threshold(new_gimg,100,255,cv2.THRESH_BINARY)   # use it Global Thresholdig or binarize image
athreshimg=cv2.adaptiveThreshold(new_gimg,255,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY,3,5)  # Adaptive Thresholdig or binarize image
value=np.array(threshimg)
sumofcolumn=np.sum(value,axis=0)
rowv=sumofcolumn[:]
sumofrow=athreshimg.sum(axis =1)
normalizerow=rowv/sumofrow[:, np.newaxis]
print("row value=",rowv)
print("value=",value)
print(value.shape)
print("nval",normalizerow)


kernel=np.ones((5,5),np.uint8)
erodedImag=cv2.erode(threshimg,kernel,iterations=1)
erodevalue=np.array(erodedImag)
sumervrow=np.sum(erodevalue,axis=1)
print("erodeVal",erodevalue)
print("esumcol",sumervrow)
#convert sum of row pixel into binary
vector=[]

for k in sumervrow:
    if k==0:
        vector.append(int(0))

    else:
        vector.append(int(1))

rowBinary=vector
print("rowBinary",rowBinary)

#count 0 and 1
def consecutive_length(rowBinary):
    def sub(idx, lst, last_char, count):
        try:
            c = rowBinary[idx]     # c will be the 'next' char
        except IndexError: # no more chars left to process
            if count:
                lst.append(count)
            return lst
        if c != last_char:
            lst.append(count)
            count = 0
        return sub(idx+1, lst, c, count+1)
    return sub(0, [], rowBinary[0] if rowBinary else None, 0)
print(consecutive_length(rowBinary))
stripwidth=consecutive_length(rowBinary)
lengthOfRow=len(stripwidth)
print("rowlength",lengthOfRow)
minval=np.min(stripwidth)
print("minval",minval)
#find the no binary digit
roundVal=[]
for j in stripwidth:
    if (j%minval==3):
      roundVal.append(round(j/minval)-1)
    else:
        roundVal.append(round(j / minval))

roundValue=roundVal
print("roundVal",roundValue)


binaryDigit=[]
if rowBinary[0]==0:
    for o in range(len(roundVal)):
        if (o%2 ==0):
            for l in range(roundVal[o]):
                binaryDigit.append(int(0))
        else:
            for l in range(roundVal[o]):
                binaryDigit.append(int(1))
else:
    for o in range(len(roundVal)):
        if (o % 2 == 0):
            for l in range(roundVal[o]):
                binaryDigit.append(int(1))
        else:
            for l in range(roundVal[o]):
                binaryDigit.append(int(0))
print(binaryDigit)
print(len(binaryDigit))
print(type(binaryDigit))

# 8 multiple bit
bitin1frame=len(binaryDigit)-(len(binaryDigit)%8)
print(bitin1frame)
bitperframe=[]
for i in range(bitin1frame):

        bitperframe.append(binaryDigit[i])
print("bitperframe\n",bitperframe)
print(type(bitperframe))

# convert "binaryDigit" list to string
binaryString =''.join(map(str,bitperframe))
print("binaryString",binaryString)
print("string lenght",len(binaryString))
print(type(binaryString))
# convert "binarystring" list to int
res = int(binaryString)
print("integer",res)
print(type(res))

input=binaryString
length = 8
input_l = [input[i:i+length] for i in range(0,len(input),length)]
print(input_l)
print(len(input_l))
outtext=[]
outdecimal=[]
for i in input_l:
  outdecimal.append(int(i, 2))
  outtext.append(chr(int(i, 2)))

print(outdecimal)
print(outtext)
#print(binascii.unhexlify('%x' % res))

diluteImg=cv2.dilate(threshimg,kernel,iterations=1) # used diluet image

# edge detection sobel
sobel_x=cv2.Sobel(threshimg,cv2.CV_64F,0,1,ksize=5)
sobel_y=cv2.Sobel(threshimg,cv2.CV_64F,1,0,ksize=5)
sobel_img=cv2.bitwise_or(sobel_x,sobel_y)

canny_img=cv2.Canny(threshimg,50,120) # used canny edge detection

# blob detection

detector_obj=cv2.SimpleBlobDetector_create()
keypoint_info=detector_obj.detect(canny_img)
blank_img=np.zeros((1,1))
blobs_img=cv2.drawKeypoints(canny_img,keypoint_info,np.array([]),(255,0,0),cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)

cnts=cv2.findContours(canny_img,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)   #count edge
cnts=imutils.grab_contours(cnts)
print(len(cnts))
#for i in erodevalue:



#cv2.imshow("output0",cap1)
cv2.imshow("output1",gimg)
cv2.imshow("new_gray",new_gimg)
cv2.imshow("threshold",threshimg)
#cv2.imshow("a_threshold",athreshimg)
cv2.imshow("eroded",erodedImag)
#cv2.imshow("diluted",diluteImg)
#cv2.imshow("sobel",sobel_img)
#cv2.imshow("canny image",canny_img)
#cv2.imshow("blob image",blobs_img)
cv2.imshow("FRAME", frame)
#cv2.imshow("ROI", roi)
cv2.waitKey(0)





import cv2

cap = cv2.VideoCapture("./out.mp4")
while not cap.isOpened():
    cap = cv2.VideoCapture("./out.mp4")
    cv2.waitKey(1000)
    print "Wait for the header"

pos_frame = cap.get(cv2.cv.CV_CAP_PROP_POS_FRAMES)
while True:
    flag, frame = cap.read()
    if flag:
        # The frame is ready and already captured
        cv2.imshow('video', frame)
        pos_frame = cap.get(cv2.cv.CV_CAP_PROP_POS_FRAMES)
        print str(pos_frame)+" frames"
    else:
        # The next frame is not ready, so we try to read it again
        cap.set(cv2.cv.CV_CAP_PROP_POS_FRAMES, pos_frame-1)
        print "frame is not ready"
        # It is better to wait for a while for the next frame to be ready
        cv2.waitKey(1000)

    if cv2.waitKey(10) == 27:
        break
    if cap.get(cv2.cv.CV_CAP_PROP_POS_FRAMES) == cap.get(cv2.cv.CV_CAP_PROP_FRAME_COUNT):
        # If the number of captured frames is equal to the total number of frames,
        # we stop
        break
